import argparse
import random
import re
import os
from typing import List, Optional, Tuple, Union

import plotly.express as px
import torch
import numpy as np

from datetime import datetime


from diffusers import StableDiffusionPipeline, DPMSolverMultistepScheduler
from diffusers.pipelines.stable_diffusion import StableDiffusionPipelineOutput
from diffusers.schedulers.scheduling_utils import SchedulerOutput
from diffusers.schedulers.scheduling_utils import KarrasDiffusionSchedulers, SchedulerMixin
from PIL import Image
from PIL.PngImagePlugin import PngInfo

class Pipeline(StableDiffusionPipeline):

    @torch.no_grad()
    def __call__(
        self,
        prompt = None,
        height = None,
        width = None,
        num_inference_steps = 50,
        guidance_scale = 7.5,
        negative_prompt = None,
        num_images_per_prompt = 1,
        eta = 0.0,
        generator = None,
        latents = None,
        prompt_embeds = None,
        negative_prompt_embeds = None,
        output_type = "pil",
        return_dict = True,
        callback = None,
        callback_steps = 1,
        cross_attention_kwargs = None,
        guidance_rescale = 0.0,
    ):
        r"""
        The call function to the pipeline for generation.

        Args:
            prompt (`str` or `List[str]`, *optional*):
                The prompt or prompts to guide image generation. If not defined, you need to pass `prompt_embeds`.
            height (`int`, *optional*, defaults to `self.unet.config.sample_size * self.vae_scale_factor`):
                The height in pixels of the generated image.
            width (`int`, *optional*, defaults to `self.unet.config.sample_size * self.vae_scale_factor`):
                The width in pixels of the generated image.
            num_inference_steps (`int`, *optional*, defaults to 50):
                The number of denoising steps. More denoising steps usually lead to a higher quality image at the
                expense of slower inference.
            guidance_scale (`float`, *optional*, defaults to 7.5):
                A higher guidance scale value encourages the model to generate images closely linked to the text
                `prompt` at the expense of lower image quality. Guidance scale is enabled when `guidance_scale > 1`.
            negative_prompt (`str` or `List[str]`, *optional*):
                The prompt or prompts to guide what to not include in image generation. If not defined, you need to
                pass `negative_prompt_embeds` instead. Ignored when not using guidance (`guidance_scale < 1`).
            num_images_per_prompt (`int`, *optional*, defaults to 1):
                The number of images to generate per prompt.
            eta (`float`, *optional*, defaults to 0.0):
                Corresponds to parameter eta (Î·) from the [DDIM](https://arxiv.org/abs/2010.02502) paper. Only applies
                to the [`~schedulers.DDIMScheduler`], and is ignored in other schedulers.
            generator (`torch.Generator` or `List[torch.Generator]`, *optional*):
                A [`torch.Generator`](https://pytorch.org/docs/stable/generated/torch.Generator.html) to make
                generation deterministic.
            latents (`torch.FloatTensor`, *optional*):
                Pre-generated noisy latents sampled from a Gaussian distribution, to be used as inputs for image
                generation. Can be used to tweak the same generation with different prompts. If not provided, a latents
                tensor is generated by sampling using the supplied random `generator`.
            prompt_embeds (`torch.FloatTensor`, *optional*):
                Pre-generated text embeddings. Can be used to easily tweak text inputs (prompt weighting). If not
                provided, text embeddings are generated from the `prompt` input argument.
            negative_prompt_embeds (`torch.FloatTensor`, *optional*):
                Pre-generated negative text embeddings. Can be used to easily tweak text inputs (prompt weighting). If
                not provided, `negative_prompt_embeds` are generated from the `negative_prompt` input argument.
            output_type (`str`, *optional*, defaults to `"pil"`):
                The output format of the generated image. Choose between `PIL.Image` or `np.array`.
            return_dict (`bool`, *optional*, defaults to `True`):
                Whether or not to return a [`~pipelines.stable_diffusion.StableDiffusionPipelineOutput`] instead of a
                plain tuple.
            callback (`Callable`, *optional*):
                A function that calls every `callback_steps` steps during inference. The function is called with the
                following arguments: `callback(step: int, timestep: int, latents: torch.FloatTensor)`.
            callback_steps (`int`, *optional*, defaults to 1):
                The frequency at which the `callback` function is called. If not specified, the callback is called at
                every step.
            cross_attention_kwargs (`dict`, *optional*):
                A kwargs dictionary that if specified is passed along to the [`AttentionProcessor`] as defined in
                [`self.processor`](https://github.com/huggingface/diffusers/blob/main/src/diffusers/models/cross_attention.py).
            guidance_rescale (`float`, *optional*, defaults to 0.7):
                Guidance rescale factor from [Common Diffusion Noise Schedules and Sample Steps are
                Flawed](https://arxiv.org/pdf/2305.08891.pdf). Guidance rescale factor should fix overexposure when
                using zero terminal SNR.

        Examples:

        Returns:
            [`~pipelines.stable_diffusion.StableDiffusionPipelineOutput`] or `tuple`:
                If `return_dict` is `True`, [`~pipelines.stable_diffusion.StableDiffusionPipelineOutput`] is returned,
                otherwise a `tuple` is returned where the first element is a list with the generated images and the
                second element is a list of `bool`s indicating whether the corresponding generated image contains
                "not-safe-for-work" (nsfw) content.
        """
        # 0. Default height and width to unet
        height = height or self.unet.config.sample_size * self.vae_scale_factor
        width = width or self.unet.config.sample_size * self.vae_scale_factor

        # 1. Check inputs. Raise error if not correct
        self.check_inputs(
            prompt, height, width, callback_steps, negative_prompt, prompt_embeds, negative_prompt_embeds
        )

        # 2. Define call parameters
        if prompt is not None and isinstance(prompt, str):
            batch_size = 1
        elif prompt is not None and isinstance(prompt, list):
            batch_size = len(prompt)
        else:
            batch_size = prompt_embeds.shape[0]

        device = self._execution_device
        # here `guidance_scale` is defined analog to the guidance weight `w` of equation (2)
        # of the Imagen paper: https://arxiv.org/pdf/2205.11487.pdf . `guidance_scale = 1`
        # corresponds to doing no classifier free guidance.
        do_classifier_free_guidance = guidance_scale > 1.0

        # 3. Encode input prompt
        text_encoder_lora_scale = (
            cross_attention_kwargs.get("scale", None) if cross_attention_kwargs is not None else None
        )
        prompt_embeds = self._encode_prompt(
            prompt,
            device,
            num_images_per_prompt,
            do_classifier_free_guidance,
            negative_prompt,
            prompt_embeds=prompt_embeds,
            negative_prompt_embeds=negative_prompt_embeds,
            lora_scale=text_encoder_lora_scale,
        )

        # 4. Prepare timesteps
        self.scheduler.set_timesteps(num_inference_steps, device=device)
        timesteps = self.scheduler.timesteps

        # 5. Prepare latent variables
        num_channels_latents = self.unet.config.in_channels

        latents = self.prepare_latents(
            batch_size * num_images_per_prompt,
            num_channels_latents,
            height,
            width,
            prompt_embeds.dtype,
            device,
            generator,
            latents,
        )
        first_latents = latents

        # 6. Prepare extra step kwargs. TODO: Logic should ideally just be moved out of the pipeline
        extra_step_kwargs = self.prepare_extra_step_kwargs(generator, eta)

        # 7. Denoising loop
        noise = []
        num_warmup_steps = len(timesteps) - num_inference_steps * self.scheduler.order
        with self.progress_bar(total=num_inference_steps) as progress_bar:
            for i, t in enumerate(timesteps):
                # expand the latents if we are doing classifier free guidance
                latent_model_input = torch.cat([latents] * 2) if do_classifier_free_guidance else latents
                latent_model_input = self.scheduler.scale_model_input(latent_model_input, t)

                # predict the noise residual
                noise_pred = self.unet(
                    latent_model_input,
                    t,
                    encoder_hidden_states=prompt_embeds,
                    cross_attention_kwargs=cross_attention_kwargs,
                    return_dict=False,
                )[0]

                # perform guidance
                if do_classifier_free_guidance:
                    noise_pred_uncond, noise_pred_text = noise_pred.chunk(2)
                    noise_pred = noise_pred_uncond + guidance_scale * (noise_pred_text - noise_pred_uncond)

                if do_classifier_free_guidance and guidance_rescale > 0.0:
                    # Based on 3.4. in https://arxiv.org/pdf/2305.08891.pdf
                    noise_pred = rescale_noise_cfg(noise_pred, noise_pred_text, guidance_rescale=guidance_rescale)
                # compute the previous noisy sample x_t -> x_t-1
                latents = self.scheduler.step(noise_pred, t, latents, **extra_step_kwargs, return_dict=False)[0]
                noise.append(latents)
                # call the callback, if provided
                if i == len(timesteps) - 1 or ((i + 1) > num_warmup_steps and (i + 1) % self.scheduler.order == 0):
                    progress_bar.update()
                    if callback is not None and i % callback_steps == 0:
                        callback(i, t, latents)

        if not output_type == "latent":
            image = self.vae.decode(latents / self.vae.config.scaling_factor, return_dict=False)[0]
            image, has_nsfw_concept = self.run_safety_checker(image, device, prompt_embeds.dtype)
        else:
            image = latents
            has_nsfw_concept = None

        if has_nsfw_concept is None:
            do_denormalize = [True] * image.shape[0]
        else:
            do_denormalize = [not has_nsfw for has_nsfw in has_nsfw_concept]

        image = self.image_processor.postprocess(image, output_type=output_type, do_denormalize=do_denormalize)

        # Offload last model to CPU
        if hasattr(self, "final_offload_hook") and self.final_offload_hook is not None:
            self.final_offload_hook.offload()

        if not return_dict:
            return (image, has_nsfw_concept)

        return StableDiffusionPipelineOutput(images=image, nsfw_content_detected=has_nsfw_concept), noise, first_latents

def encode_prompt_from_word_embeds(
    word_embeds,
    device,
    num_images_per_prompt,
):
    r"""

    This method is adapted from StableDiffusionPipeline.encode_prompt so that we can encode a prompt from the 
    token embeddings using CustomCLIPTextTransformer rather on just the token ids.

    Encodes the prompt into text encoder hidden states.

    Args:
            prompt (`str` or `List[str]`, *optional*):
            prompt to be encoded
        device: (`torch.device`):
            torch device
        num_images_per_prompt (`int`):
            number of images that should be generated per prompt
    """

    text_encoder = CustomCLIPTextTransformer(pipe)

    prompt_embeds = text_encoder(
        word_embeds
    )
    prompt_embeds = prompt_embeds[0]

    prompt_embeds = prompt_embeds.to(dtype=pipe.text_encoder.dtype, device=device)

    bs_embed, seq_len, _ = prompt_embeds.shape
    # duplicate text embeddings for each generation per prompt, using mps friendly method
    prompt_embeds = prompt_embeds.repeat(1, num_images_per_prompt, 1)
    prompt_embeds = prompt_embeds.view(bs_embed * num_images_per_prompt, seq_len, -1)

    return prompt_embeds

from torch import nn
from transformers.modeling_outputs import BaseModelOutputWithPooling
class CustomCLIPTextTransformer(nn.Module):
    '''
    The point of re-definining this class is here is to have a version that accepts
    token embeddings directly instead of token ids.
    '''
    def __init__(self, pipe):
        super().__init__()
        self.config = pipe.text_encoder.text_model.config
        embed_dim = self.config.hidden_size
        self.embeddings = pipe.text_encoder.text_model.embeddings
        self.encoder = pipe.text_encoder.text_model.encoder
        self.final_layer_norm = pipe.text_encoder.text_model.final_layer_norm#nn.LayerNorm(embed_dim, eps=self.config.layer_norm_eps, device=pipe.device)

    def _build_causal_attention_mask(self, bsz, seq_len, dtype):
        # lazily create causal attention mask, with full attention between the vision tokens
        # pytorch uses additive attention mask; fill with -inf
        mask = torch.empty(bsz, seq_len, seq_len, dtype=dtype)
        mask.fill_(torch.tensor(torch.finfo(dtype).min))
        mask.triu_(1)  # zero out the lower diagonal
        mask = mask.unsqueeze(1)  # expand mask
        return mask
    
    def forward(
        self,
        input_embeds: Optional[torch.Tensor] = None,
        attention_mask: Optional[torch.Tensor] = None,
        position_ids: Optional[torch.Tensor] = None,
        output_attentions: Optional[bool] = None,
        output_hidden_states: Optional[bool] = None,
        return_dict: Optional[bool] = None,
    ):
        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions
        output_hidden_states = (
            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states
        )
        return_dict = return_dict if return_dict is not None else self.config.use_return_dict

        input_shape = input_embeds.size()

        hidden_states = input_embeds

        bsz, seq_len, _ = input_shape
        # CLIP's text model uses causal mask, prepare it here.
        # https://github.com/openai/CLIP/blob/cfcffb90e69f37bf2ff1e988237a0fbe41f33c04/clip/model.py#L324
        causal_attention_mask = self._build_causal_attention_mask(bsz, seq_len, hidden_states.dtype).to(
            hidden_states.device
        )
        # expand attention_mask
        if attention_mask is not None:
            # [bsz, seq_len] -> [bsz, 1, tgt_seq_len, src_seq_len]
            attention_mask = _expand_mask(attention_mask, hidden_states.dtype)

        encoder_outputs = self.encoder(
            inputs_embeds=hidden_states,
            attention_mask=attention_mask,
            causal_attention_mask=causal_attention_mask,
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            return_dict=return_dict,
        )

        last_hidden_state = encoder_outputs[0]
        last_hidden_state = self.final_layer_norm(last_hidden_state.to(dtype=self.final_layer_norm.weight.dtype))

        # text_embeds.shape = [batch_size, sequence_length, transformer.width]
        # take features from the eot embedding (eot_token is the highest number in each sequence)
        # casting to torch.int for onnx compatibility: argmax doesn't support int64 inputs with opset 14
        # 
        # NOTE that the creal CLIPTextTransformer handles batches of different sequence lengths like this:
        #
        # pooled_output = last_hidden_state[
        #    torch.arange(last_hidden_state.shape[0], device=last_hidden_state.device),
        #    input_ids.to(dtype=torch.int, device=last_hidden_state.device).argmax(dim=-1),
        # ]
        pooled_output = last_hidden_state[:, -1]

        if not return_dict:
            return (last_hidden_state, pooled_output) + encoder_outputs[1:]

        return BaseModelOutputWithPooling(
            last_hidden_state=last_hidden_state,
            pooler_output=pooled_output,
            hidden_states=encoder_outputs.hidden_states,
            attentions=encoder_outputs.attentions,
        )

def get_word_embeds(pipe, prompt):
    text_inputs = pipe.tokenizer(
        prompt,
        padding="max_length",
        max_length=pipe.tokenizer.model_max_length,
        truncation=True,
        return_tensors="pt",
    )
    text_input_ids = text_inputs.input_ids
    return pipe.text_encoder.text_model.embeddings(text_input_ids.to('cuda'))

def embed_prompt(pipe, prompt):
    prompt_embeds = pipe._encode_prompt(
        prompt,
        device='cuda',
        num_images_per_prompt=1,
        do_classifier_free_guidance=True, # should be true if guidance_scale > 1.0
        negative_prompt=None,
        prompt_embeds=None,
        negative_prompt_embeds=None,
        lora_scale=None,
    )
    return prompt_embeds[1] # the negative prompt embed is concatenated on top of positive, here we return just the positive ones

def prepare_latents(pipe, generator, prompt_embeds):
    num_channels_latents = pipe.unet.config.in_channels
    latents = pipe.prepare_latents(
        1, #batch_size * num_images_per_prompt,
        num_channels_latents,
        pipe.unet.config.sample_size * pipe.vae_scale_factor, # height
        pipe.unet.config.sample_size * pipe.vae_scale_factor, # width
        prompt_embeds.dtype,
        pipe._execution_device,
        generator,
    )
    return latents

def slerp(p0, p1, t):
    """Spherical Linear Interpolation between two points."""
    shape = np.copy(p0.shape)
    p0 = np.reshape(p0, [-1])
    p1 = np.reshape(p1, [-1])
    omega = np.arccos(np.dot(p0 / np.linalg.norm(p0), p1 / np.linalg.norm(p1)))
    sin_omega = np.sin(omega)
    
    if sin_omega == 0:
        return (1.0 - t) * p0 + t * p1
    
    rotated = np.sin((1.0 - t) * omega) / sin_omega * p0 + np.sin(t * omega) / sin_omega * p1
    return np.reshape(rotated, shape)

def interpolate(start, target, nframes, type):
    if type == 'linear':
        interpolations = np.linspace(start, target, nframes)[1:]
    elif type == 'slerp':
        interpolated_points = []
        for i in range(nframes):
            t = i / (nframes - 1)
            interpolated = slerp(start, target, t)
            interpolated_points.append(interpolated)
        interpolations = np.array(interpolated_points)
    else:
        raise ValueError(f'Unrecognized interpolation type {type}')
    return interpolations

def word_by_word_interpolation(pipe, start_prompt, target_prompt, nframes):
    # Step 1: Split prompts into words
    start_words = start_prompt.split()
    target_words = target_prompt.split()
    max_words = max(len(start_words), len(target_words))

    # Embed the entire start and target prompts
    start_prompt_embeds = embed_prompt(pipe, start_prompt).cpu().detach().numpy()
    target_prompt_embeds = embed_prompt(pipe, target_prompt).cpu().detach().numpy()

    # Step 2: Calculate frames per transition, distributing extra frames evenly
    frames_per_transition = nframes // max_words
    extra_frames = nframes % max_words  # Extra frames to distribute

    # Initialize list to store the interpolated frames
    prompt_interpolations = []

    # Step 3: Interpolate embeddings, gradually replacing words
    previous_embeds = start_prompt_embeds
    previous_prompt = start_prompt
    current_words = start_words.copy()
    for i in range(len(start_words) + len(target_words)):
        # Calculate the number of frames for this transition, adding 1 if extra frames remain
        transition_frames = frames_per_transition + (1 if i < extra_frames else 0)
        '''
        # Create current prompt by replacing up to `i+1` words from the start prompt with words from the target prompt
        current_words = start_words.copy()
        for j in range(i + 1):
            if j < len(target_words):  # Ensure we stay within bounds of target words
                if j < len(current_words):  # Ensure we stay within bounds of start words
                    current_words[j] = target_words[j]
                else:
                    current_words.append(target_words[j])

        # If we have replaced all target words and still have extra start words, trim from the end
        if i + 1 > len(target_words) and len(current_words) > len(target_words):
            current_words = current_words[:len(target_words)]
        '''        
        print(i, len(start_words), len(target_words))
        if i < len(target_words):
            current_words.append(target_words[i])
        else:
            current_words = current_words[1:]
    
        # Embed the current prompt with modified words
        current_prompt = " ".join(current_words)
        if current_prompt == previous_prompt:
            continue
        current_embeds = embed_prompt(pipe, current_prompt).cpu().detach().numpy()
        print(previous_prompt)
        print(current_prompt)
        print()

        # Interpolate between the previous embeddings and the current embeddings
        interpolated_embeds = interpolate(
            previous_embeds,
            current_embeds,
            transition_frames,
            'linear'
        )

        # Append interpolated embeddings for this transition
        prompt_interpolations.extend(interpolated_embeds)

        # Update previous embeddings to the current embeddings for the next iteration
        previous_embeds = current_embeds
        previous_prompt = current_prompt

    print(target_prompt)

    # Ensure we return exactly nframes
    if len(prompt_interpolations) > nframes:
        prompt_interpolations = prompt_interpolations[:nframes]

    return prompt_interpolations

def rising_falling_trajectory(N):
    # Create a tensor of evenly spaced points from 0 to pi
    x = torch.linspace(0, torch.pi, steps=N)
    # Apply sine function to create the rising and falling trajectory
    trajectory = torch.sin(x)
    return trajectory

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--start_image', required=True, type=str)
    parser.add_argument('--target_image', required=True, type=str)
    parser.add_argument('--steps', default=50, type=int)
    parser.add_argument('--nframes', default=100, type=int)
    parser.add_argument('--destination', default='./prompt-interp', type=str)
    args = parser.parse_args()

    if not os.path.exists(args.destination):
        os.makedirs(args.destination)

    pipe = Pipeline.from_pretrained(
        'stabilityai/stable-diffusion-2-1-base',
        torch_dtype=torch.float16,
    )
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    pipe = pipe.to("cuda")
    print(pipe.components.keys())

    start_image = Image.open(args.start_image)
    metadata = start_image.info
    start_seed = float(metadata['seed'])
    start_prompt = metadata['prompt']
    print(start_prompt)
    print(start_seed)

    target_image = Image.open(args.target_image)
    metadata = target_image.info
    target_seed = float(metadata['seed'])
    target_prompt = metadata['prompt'] 
    print(target_prompt)
    print(target_seed)

    # PROMPT INTERPOLATION
    # We split the embedding layer from the rest of the encoder so that we can 
    # interpolate over the inputs rather than the outputs of the text encoder 
    start_prompt_word_embeds = get_word_embeds(pipe, start_prompt)
    start_prompt_embeds= encode_prompt_from_word_embeds(start_prompt_word_embeds, 'cuda', 1)[0]
    target_prompt_word_embeds = get_word_embeds(pipe, target_prompt)
    target_prompt_embeds = encode_prompt_from_word_embeds(target_prompt_word_embeds, 'cuda', 1)[0]

    prompt_interpolations = interpolate(
        start_prompt_word_embeds.cpu().detach().numpy(),
        target_prompt_word_embeds.cpu().detach().numpy(),
        args.nframes,
        'linear'
    )
 
    encoded_interpolations = []
    for interp_sample in prompt_interpolations:
        interp_sample = torch.from_numpy(interp_sample).to('cuda')
        encoded_interpolations.append(
            encode_prompt_from_word_embeds(interp_sample, 'cuda', 1).cpu().detach().numpy()[0]
        )
    prompt_interpolations = np.stack(encoded_interpolations)
    '''
    print(start_prompt_embeds.shape)

    start_prompt_embeds = embed_prompt(pipe, start_prompt)
    print(start_prompt_embeds.shape)
    target_prompt_embeds = embed_prompt(pipe, target_prompt)
    print(prompt_interpolations.shape)
    prompt_interpolations = interpolate(
        start_prompt_embeds.cpu().detach().numpy(),
        target_prompt_embeds.cpu().detach().numpy(),
        args.nframes,
        'slerp'
    )
    '''
    print(prompt_interpolations.shape)


    # START IMAGE
    start_generator = torch.manual_seed(start_seed)
    pipe_out, start_noise, start_latents = pipe(
        prompt=None,
        prompt_embeds=start_prompt_embeds[None],
        generator=start_generator,
        num_inference_steps=args.steps
    )
    start_image = pipe_out.images[0]
    start_image.save(f'{args.destination}/start.png')
    start_std, start_mean = torch.std_mean(start_latents, keepdim=True)

    # TARGET IMAGE
    target_generator = torch.manual_seed(target_seed)
    pipe_out, target_noise, target_latents = pipe(
        prompt_embeds=target_prompt_embeds[None],
        generator=target_generator,
        num_inference_steps=args.steps
    )
    target_image = pipe_out.images[0]
    target_image.save(f'{args.destination}/target.png')

    #########################################
    # LATENT SLERP
    start_latents = start_latents.cpu().detach().numpy()
    target_latents = target_latents.cpu().detach().numpy()
    latent_interpolations = interpolate(start_latents, target_latents, args.nframes, 'slerp')

    # NOISE INTERPOLATION
    noise_interpolations = []
    start_noise = [noise.cpu().detach().numpy() for noise in start_noise]
    target_noise = [noise.cpu().detach().numpy() for noise in target_noise]
    for s_noise, t_noise in zip(start_noise, target_noise):
        noise_interpolations.append(
            interpolate(s_noise, t_noise, args.nframes, 'linear')
        )
    noise_interpolations = np.concatenate(noise_interpolations, axis=1)

    #################################################

    images = [start_image]
    # IMAGE-PROMPT INTERPOLATION
    pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)
    for i, prompt_embed in enumerate(prompt_interpolations):
        start_generator = torch.manual_seed(start_seed)
        pipe_out, middle_noise, middle_latents = pipe(
            prompt_embeds=torch.from_numpy(prompt_embed).to('cuda')[None],
            generator=start_generator,
            num_inference_steps=args.steps
        )
        image = pipe_out.images[0]
        image.save(f'{args.destination}/image_{len(images)}.png')
        images.append(image)

    # IMAGE-LATENT INTERPOLATION
    for i, (noise, latents) in enumerate(
        zip(noise_interpolations, latent_interpolations)
    ):
#        pipe.scheduler.reset(torch.from_numpy(noise).to('cuda')[:, None])
#        target_generator = torch.manual_seed(target_seed)
        start_generator = torch.manual_seed(start_seed)
        pipe_out, _, _ = pipe(
            prompt_embeds=target_prompt_embeds[None],
            latents=torch.from_numpy(latents).to('cuda'),
            generator=start_generator,
            num_inference_steps=args.steps
        )
        image = pipe_out.images[0]
        image.save(f'{args.destination}/image_{len(images)}.png')
        images.append(image)
    images.append(target_image)

    # SAVE GIFs
    images += images[2:-1][::-1]
    for fps in [2, 4, 8, 16, 32]:
        images[0].save(
            f'{args.destination}/transition_{fps}fps.gif',
            save_all=True,
            append_images=images[1:],
            duration = 1000 // fps,
            loop=0
        )

